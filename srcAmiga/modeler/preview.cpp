/***************
 * PROGRAM:       Modeler
 * NAME:          preview.cpp
 * DESCRIPTION:   this class renders the preview in the attributes window
 * AUTHORS:       Andreas Heumann
 * HISTORY:
 *    DATE     NAME  COMMENT
 *    03.11.96 ah    initial release
 *    16.11.96 ah    added preview of textures
 ***************/

#include <string.h>

#ifdef __AMIGA__
#include <pragma/dos_lib.h>
#include <pragma/exec_lib.h>
#include "rtxt:texture_module.h"
#if !defined(__MIXEDBINARY__) || defined(__PPC__)
struct Library *TextureBase;
#endif
#endif

#ifndef TYPEDEFS_H
#include "typedefs.h"
#endif

#ifndef PREVIEW_H
#include "preview.h"
#endif

#ifndef GLOBALS_H
#include "globals.h"
#endif

#ifndef __AMIGA__
#ifdef __WATCOMC__
typedef IM_TTABLE __cdecl *(*INQUIRETEXTURE)(int, int);
#else
typedef IM_TTABLE *(*INQUIRETEXTURE)(int, int);
#endif
#endif

static UBYTE reflmap[] =
{
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff, 0xff,0xff,0xff,
	0xff,0xff,0xff, 0xff,0xff,0xff, 0xff,0xff,0xff, 0xff,0xff,0xff,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff,
	0xff,0xff,0xff, 0xff,0xff,0xff, 0xff,0xff,0xff, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff,
	0xff,0xff,0xff, 0xff,0xff,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff, 0xff,0xff,0xff,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff, 0xff,0xff,0xff,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xff,0xff,0xff, 0xff,0xff,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff,
	0xff,0xff,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff,
	0xff,0xff,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xff,0xff,0xff, 0xff,0xff,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xff,0xff,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0x4a,0x63,0xff, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xb5,0x9c,0x6b,
	0xbd,0x9c,0x6b, 0xad,0x9c,0x6b, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0x7b,0x8c,0xff, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0x6b,0x63,0x5a, 0xff,0xef,0xef, 0xff,0xef,0xef,
	0xde,0xc6,0x7b, 0xde,0xc6,0x7b, 0xff,0xef,0xef, 0x8c,0x7b,0x63,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff, 0xde,0xde,0xde,
	0x4a,0x63,0xff, 0x4a,0x63,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xf7,0xef,0xef, 0xff,0xef,0xef, 0xff,0xef,0xef,
	0xef,0xd6,0x7b, 0xef,0xd6,0x84, 0xe7,0xce,0x7b, 0x8c,0x7b,0x4a,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0x84,0x94,0xff,
	0x7b,0x8c,0xff, 0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff,
	0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0x4a,0x63,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0x8c,0x7b,0x5a, 0xf7,0xef,0xef, 0xff,0xef,0xef,
	0xff,0xef,0xef, 0xff,0xe7,0x7b, 0xef,0xd6,0x7b, 0xff,0xef,0xef,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0x8c,0x94,0xff,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff,
	0xde,0xde,0xde, 0xff,0xff,0xff, 0xde,0xde,0xde, 0x4a,0x63,0xff,
	0x4a,0x63,0xff, 0x4a,0x63,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0x6b,0x6b,0x6b, 0xf7,0xef,0xef, 0xff,0xef,0xef,
	0xff,0xef,0xef, 0xff,0xef,0xef, 0xe7,0xce,0x7b, 0x94,0x8c,0x7b,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0x8c,0x94,0xff,
	0x84,0x94,0xff, 0x73,0x8c,0xff, 0xde,0xde,0xde, 0xff,0xff,0xff,
	0xde,0xde,0xde, 0xff,0xff,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0x4a,0x63,0xff, 0x4a,0x63,0xff, 0x4a,0x63,0xff, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0x7b,0x6b,0x63, 0xf7,0xef,0xef, 0xff,0xef,0xef,
	0xff,0xef,0xef, 0xff,0xef,0xef, 0xbd,0xa5,0x6b, 0xff,0xef,0xef,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0x8c,0x9c,0xff, 0x84,0x94,0xff,
	0x7b,0x8c,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff,
	0xde,0xde,0xde, 0xff,0xff,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0x4a,0x63,0xff, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xef,0xef, 0xf7,0xef,0xef,
	0xff,0xef,0xef, 0xff,0xef,0xef, 0xff,0xef,0xef, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0x84,0x94,0xff, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff,
	0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff, 0xde,0xde,0xde,
	0x4a,0x63,0xff, 0x4a,0x63,0xff, 0x4a,0x63,0xff, 0x52,0x63,0xff,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0x84,0x94,0xff, 0x84,0x94,0xff, 0x7b,0x8c,0xff,
	0x73,0x84,0xff, 0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff,
	0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff, 0xde,0xde,0xde,
	0x4a,0x63,0xff, 0x4a,0x63,0xff, 0xde,0xde,0xde, 0x4a,0x63,0xff,
	0x52,0x63,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0x29,0x31,0x9c, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0x7b,0x8c,0xff, 0x7b,0x8c,0xff, 0xde,0xde,0xde, 0x73,0x84,0xff,
	0x6b,0x84,0xff, 0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0x4a,0x63,0xff,
	0x52,0x63,0xff, 0x52,0x6b,0xff, 0x52,0x6b,0xff, 0x4a,0x63,0xef,
	0x4a,0x63,0xff, 0x4a,0x63,0xff, 0x6b,0x7b,0xff, 0x6b,0x84,0xff,
	0x73,0x84,0xff, 0x73,0x84,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff,
	0xde,0xde,0xde, 0x4a,0x63,0xff, 0x4a,0x63,0xff, 0x4a,0x63,0xff,
	0xde,0xde,0xde, 0x52,0x63,0xff, 0x18,0x29,0xa5, 0x4a,0x63,0xff,
	0x7b,0x8c,0xff, 0x4a,0x63,0xff, 0x10,0x29,0xbd, 0x63,0x7b,0xff,
	0xde,0xde,0xde, 0x63,0x7b,0xff, 0x63,0x7b,0xff, 0x63,0x73,0xff,
	0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0x4a,0x63,0xff,
	0xde,0xde,0xde, 0x4a,0x63,0xff, 0x18,0x21,0x84, 0x4a,0x63,0xef,
	0x4a,0x63,0xff, 0x4a,0x63,0xff, 0x21,0x31,0xce, 0x5a,0x73,0xff,
	0xde,0xde,0xde, 0x5a,0x73,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xff,0xff,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff,
	0xff,0xff,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0x4a,0x63,0xff, 0xde,0xde,0xde, 0x42,0x4a,0x9c,
	0x21,0x39,0xad, 0x4a,0x52,0xbd, 0xde,0xde,0xde, 0x52,0x6b,0xff,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xff,0xff,0xff, 0xff,0xff,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xff,0xff,0xff, 0xff,0xff,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff,
	0xff,0xff,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff, 0xff,0xff,0xff,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff, 0xff,0xff,0xff,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff,
	0xff,0xff,0xff, 0xff,0xff,0xff, 0xff,0xff,0xff, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff,
	0xff,0xff,0xff, 0xff,0xff,0xff, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xff,0xff,0xff, 0xff,0xff,0xff, 0xff,0xff,0xff,
	0xff,0xff,0xff, 0xff,0xff,0xff, 0xff,0xff,0xff, 0xff,0xff,0xff,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
	0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde, 0xde,0xde,0xde,
};

/**********
 * DESCRIPTION:   constructor
 * INPUT:         -
 * OUTPUT:        -
 **********/
PREVIEW::PREVIEW()
{
	line = NULL;

	// light is the vector from O to light
	light.x = 10.f;
	light.y = -10.f;
	light.z = 20.f;
	VecNormalize(&light);

	texture_root = NULL;
}

/**********
 * DESCRIPTION:   destructor
 * INPUT:         -
 * OUTPUT:        -
 **********/
PREVIEW::~PREVIEW()
{
	PREVIEW_TEXTURE *ptexture, *next;

	if(line)
		delete [ ] line;
	ptexture = texture_root;
	while(ptexture)
	{
		next = (PREVIEW_TEXTURE*)ptexture->GetNext();
		delete ptexture;
		ptexture = next;
	}
}

/**********
 * DESCRIPTION:   set preview resolution and allocate line buffer
 * INPUT:         xres,yres   resultion
 *                lines       calculated lines per call
 *                surf        surface
 *                obj         object to preview
 * OUTPUT:        FALSE if failed, else TRUE
 **********/
BOOL PREVIEW::Init(int xres, int yres, int lines, SURFACE *surf, OBJECT *obj)
{
	TEXTURE *texture;
	PREVIEW_TEXTURE *ptexture, *next;
	TEXTURE_OBJECT *to=NULL;
	MATRIX m, m1;
	VECTOR size;

	this->xres = xres;
	this->yres = yres;
	this->lines = lines;

	if(line)
		delete line;

	line = new rsiSMALL_COLOR[xres*yres];
	if(!line)
		return FALSE;

	ambient = surf->ambient;
	diffuse = surf->diffuse;
	specular = surf->specular;
	reflect = surf->reflect;
	transpar = surf->transpar;
	difftrans = surf->difftrans;
	spectrans = surf->spectrans;
	refphong = surf->refphong;
	transphong = surf->transphong;
	foglength = surf->foglength;
	refrindex = surf->refrindex;
	translucency = surf->translucency;

	this->surf = surf;

	if(obj)
	{
		m.SetOMatrix(&obj->orient_x, &obj->orient_y, &obj->orient_z);
		m.InvMat(&m1);

		size.x = (obj->bboxmax.x - obj->bboxmin.x) * .5f;
		size.y = (obj->bboxmax.y - obj->bboxmin.y) * .5f;
		size.z = (obj->bboxmax.z - obj->bboxmin.z) * .5f;
	}
	else
	{
		m1.IdentityMatrix();
		SetVector(&size, 1.f, 1.f, 1.f);
	}

	ptexture = texture_root;
	while(ptexture)
	{
		next = (PREVIEW_TEXTURE*)ptexture->GetNext();
		delete ptexture;
		ptexture = next;
	}
	texture_root = NULL;

	texture = surf->texture;
	while(texture)
	{
#ifdef __PPC__
		switch(GetType(texture))
#else
		switch(texture->GetType())
#endif
		{
			case TEXTURE_IMAGINE:
				ptexture = (PREVIEW_TEXTURE*)new IPREVIEW_TEXTURE;
				break;
			case TEXTURE_RAYSTORM:
				ptexture = (PREVIEW_TEXTURE*)new RPREVIEW_TEXTURE;
				break;
		}
		if(!ptexture)
			return FALSE;

		if(obj)
		{
			// search texture object for this texture
			to = obj->texture;
			while(to && (to->texture != texture))
#ifdef __PPC__
				to = GetNext(to);
#else
				to = (TEXTURE_OBJECT*)to->GetNext();
#endif
		}

		if(to)
		{
			ptexture->orient_x = to->orient_x;
			ptexture->orient_y = to->orient_y;
			ptexture->orient_z = to->orient_z;
			m1.MultMatOrient(&ptexture->orient_x, &ptexture->orient_x, &ptexture->orient_x);

			ptexture->size.x = to->size.x / size.x;
			ptexture->size.y = to->size.y / size.y;
			ptexture->size.z = to->size.z / size.z;

			ptexture->pos.x = to->pos.x / size.x;
			ptexture->pos.y = to->pos.y / size.y;
			ptexture->pos.z = to->pos.z / size.z;
		}
		else
		{
			SetVector(&ptexture->pos, 0.f, 0.f, 0.f);

			SetVector(&ptexture->orient_x, 1.f, 0.f, 0.f);
			SetVector(&ptexture->orient_y, 0.f, 1.f, 0.f);
			SetVector(&ptexture->orient_z, 0.f, 0.f, 1.f);
			m1.MultMatOrient(&ptexture->orient_x, &ptexture->orient_x, &ptexture->orient_x);

			ptexture->size.x = 1.f / size.x;
			ptexture->size.y = 1.f / size.y;
			ptexture->size.z = 1.f / size.z;
		}

		ptexture->m.SetSOTMatrix(&ptexture->size, &ptexture->orient_x, &ptexture->orient_y, &ptexture->orient_z, &ptexture->pos);

		if(!ptexture->Load(texture))
			delete ptexture;
		else
			ptexture->Append((SLIST**)&texture_root);

#ifdef __PPC__
		texture = GetNext(texture);
#else
		texture = (TEXTURE*)texture->GetNext();
#endif
	}

	return TRUE;
}

/*************
 * DESCRIPTION:   Calculate direction of refracted ray using Heckbert's formula.
 *                Returns TRUE if a total internal reflection occurs.
 * INPUT:         dir      direction vector
 *                index    index of refraction
 *                norm     surface normal
 * OUTPUT:        TRUE if TIR occurs, else FALSE
 *************/
static BOOL Refract(VECTOR *newdir, float index, VECTOR *norm, float cos1)
{
	float cos2, k;
	VECTOR nrm, dir;

	if (cos1 < 0.f)
	{
		// Hit the 'backside' of a surface -- flip the normal.
		nrm.x = -norm->x;
		nrm.y = -norm->y;
		nrm.z = -norm->z;
		cos1 = -cos1;
	}
	else
	{
		nrm = *norm;
	}

	cos2 = 1.f - index*index*(1. - cos1*cos1);
	if (cos2 < 0.f)
		return TRUE;      // Total internal reflection

	k =  - sqrt((double)cos2) + index * cos1;
	SetVector(&dir, 0.f, 0.f, 1.f);
	VecComb(index, &dir, k, &nrm, newdir);

	return FALSE;
}

/*************
 * DESCRIPTION:   return the color of the reflection map in the ray direction
 * INPUT:         dir      current ray direction
 *                color    returned color
 * OUTPUT:        none
 *************/
static void ApplyReflMap(VECTOR *dir, COLOR *color)
{
	float phi, theta, u, v;
	int x, y, index;

	if (dir->y > 1.f) // roundoff
		phi = PI;
	else
	{
		if (dir->y < -1.f) // roundoff
			phi = 0.f;
		else
			phi = acos(dir->y);
	}

	v = phi * INV_PI;

	if (fabs(v) < EPSILON || equal(v, 1.f))
	{
		u = 0.f;
	}
	else
	{
		theta = dir->x / sin(phi);
		if (theta > 1.f)
			theta = 0.f;
		else
		{
			if (theta < -1.f)
				theta = 0.5f;
			else
				theta = acos(theta) * INV_TWOPI;
		}

		if (dir->z > 0.f)
			u = 1.f - theta;
		else
			u = theta;
	}
	u *= 144;
	v *= 72;
	x = int(u) % 24;
	y = int(v) % 24;

	index = (y*24 + x)*3;
	color->r = (float)(reflmap[index])*3.921568627e-3f;
	color->g = (float)(reflmap[index+1])*3.921568627e-3f;
	color->b = (float)(reflmap[index+2])*3.921568627e-3f;
}

/**********
 * DESCRIPTION:   calculate pixel color
 * INPUT:         x        x position
 *                y        y position
 *                normal   surface normal
 * OUTPUT:        -
 **********/
void PREVIEW::CalcPixel(int x, int y, VECTOR *normal)
{
	PREVIEW_TEXTURE *ptexture;
	float costheta;
	float cosalpha,intens;
	VECTOR refl, newdir, norm, pos;
	float t;
	COLOR color, map;
	float x1,y1;

	norm = *normal;
	pos = norm;

	ptexture = texture_root;
	while(ptexture)
	{
		ptexture->Work(this, &pos, &norm);
		ptexture = (PREVIEW_TEXTURE*)ptexture->GetNext();
	}

	color.r = ambient.r * global.ambient.r;
	color.g = ambient.g * global.ambient.g;
	color.b = ambient.b * global.ambient.b;

	if(surf->flags & SURF_BRIGHT)
	{
		color.r += diffuse.r;
		color.g += diffuse.g;
		color.b += diffuse.b;
	}
	else
	{
		t = -2.f*norm.z;
		refl.x = t*norm.x;
		refl.y = t*norm.y;
		refl.z = 1.f + t*norm.z;

		costheta = -dotp(&norm, &light);
		if(costheta <= 0.f)
		{
			/* Light source is on opposite side of surface, hence light must be
			 * transmitted through ... */
			if(translucency > EPSILON)
			{
				color.r += -costheta * difftrans.r;
				color.g += -costheta * difftrans.g;
				color.b += -costheta * difftrans.b;
				if(transphong > EPSILON)
				{
					/* calculate reflected ray direction */
					cosalpha = -dotp(&refl, &light);
					if(cosalpha > EPSILON)
					{
						/* Specular highlight = cosine of the angle raised to the
						 * appropriate power */
						intens = pow(cosalpha, transphong) * translucency;
						color.r += intens * spectrans.r;
						color.g += intens * spectrans.g;
						color.b += intens * spectrans.b;
					}
				}
			}
		}
		else
		{
			if(costheta > EPSILON)
			{
				color.r += costheta * diffuse.r;
				color.g += costheta * diffuse.g;
				color.b += costheta * diffuse.b;
			}
			if(refphong > EPSILON)
			{
				/* calculate reflected ray direction */
				cosalpha = -dotp(&refl, &light);
				if(cosalpha > EPSILON)
				{
					intens = pow(cosalpha, refphong);
					color.r += intens * specular.r;
					color.g += intens * specular.g;
					color.b += intens * specular.b;
				}
			}
		}

		if(transpar.r > EPSILON ||
			transpar.g > EPSILON ||
			transpar.b > EPSILON)
		{
			if(!Refract(&newdir, 1.f/refrindex, &norm, norm.z))
			{
				color.r = color.r * (1.-transpar.r);
				color.g = color.g * (1.-transpar.g);
				color.b = color.b * (1.-transpar.b);

				t = (pos.z + .5f) / newdir.z;
				x1 = (pos.x + newdir.x * t) * 4.f;
				y1 = (pos.y + newdir.y * t) * 4.f;

				if(x1 < 0.f)
					x1 -= 1.f;
				if(y1 < 0.f)
					y1 -= 1.f;
				if(((int)x1 + (int)y1) & 1)
				{
					color.r += transpar.r;
					color.g += transpar.g;
					color.b += transpar.b;
				}
			}
		}

		if(reflect.r > EPSILON ||
			reflect.g > EPSILON ||
			reflect.b > EPSILON)
		{
			ApplyReflMap(&norm, &map);
			color.r += reflect.r * map.r;
			color.g += reflect.g * map.g;
			color.b += reflect.b * map.b;
		}
	}

	if(texture_root)
	{
		ambient = surf->ambient;
		diffuse = surf->diffuse;
		specular = surf->specular;
		reflect = surf->reflect;
		transpar = surf->transpar;
		difftrans = surf->difftrans;
		spectrans = surf->spectrans;
		refphong = refphong;
		transphong = transphong;
		foglength = foglength;
		refrindex = refrindex;
		translucency = translucency;
	}

	if(color.r > 1.f)
	{
		t = 1.f/color.r;
		color.r = 1.f;
		color.g *= t;
		color.b *= t;
	}
	if(color.g > 1.f)
	{
		t = 1.f/color.g;
		color.r *= t;
		color.g = 1.f;
		color.b *= t;
	}
	if(color.b > 1.f)
	{
		t = 1.f/color.b;
		color.r *= t;
		color.g *= t;
		color.b = 1.f;
	}
	line[x + y*xres].r = (UBYTE)(color.r*255.f);
	line[x + y*xres].g = (UBYTE)(color.g*255.f);
	line[x + y*xres].b = (UBYTE)(color.b*255.f);
}

/*************
 * DESCRIPTION:   render one preview line
 * INPUT:         y     line number
 * OUTPUT:        -
 *************/
void PREVIEW::RenderLines(int ystart)
{
	int x,y;
	float x1,y1;
	VECTOR pos;
	int r, halfwidth, halfheight, double_y;
	float invhalfwidth, double_posy;

	// precalculate values
	halfwidth = xres>>1;
	invhalfwidth = 1.f/(float)halfwidth;
	halfheight = yres>>1;

	r = (xres*yres)>>2;

	for(y = ystart; y<ystart+lines; y++)
	{
		pos.y = -(float)(y - (halfheight)) / (float)(halfheight);
		double_posy = pos.y*pos.y;
		double_y = (y - halfheight)*(y - halfheight);

		y1 = pos.y * 4;
		if(y1 < 0.f)
			y1 -= 1.f;

		for(x = -halfwidth; x<halfwidth; x++)
		{
			pos.x = (float)x * invhalfwidth;
			if(x*x + double_y < r)
			{
				pos.z = -sqrt(1.f - pos.x*pos.x - double_posy);
				this->CalcPixel(x + halfwidth, y, &pos);
			}
			else
			{
				x1 = pos.x * 4.f;

				if(x1 < 0.)
					x1 -= 1.f;
				if(((int)x1 + (int)y1) & 1)
				{
					line[x+halfwidth + y*xres].r = 255;
					line[x+halfwidth + y*xres].g = 255;
					line[x+halfwidth + y*xres].b = 255;
				}
				else
				{
					line[x+halfwidth + y*xres].r = 0;
					line[x+halfwidth + y*xres].g = 0;
					line[x+halfwidth + y*xres].b = 0;
				}
			}
		}
	}
}

/*************
 * DESCRIPTION:   constructor
 * INPUT:         -
 * OUTPUT:        -
 *************/
IPREVIEW_TEXTURE::IPREVIEW_TEXTURE()
{
	static VECTOR ray = { 0.f, 0.f, 1.f };
#ifdef __AMIGA__
	seglist = NULL;
#else
	hInst = 0;
#endif
	ttable = NULL;

	patch.ptc_shp = 2;
	patch.ptc_shd = TRUE;
	patch.ptc_ray = &ray;
	patch.raydist = 1.f;
	patch.foglen = 0;
}

/*************
 * DESCRIPTION:   destructor
 * INPUT:         -
 * OUTPUT:        -
 *************/
IPREVIEW_TEXTURE::~IPREVIEW_TEXTURE()
{
	if(ttable)
		if(ttable->cleanup)
#ifdef __PPC__
			ITextureCleanup(ttable);
#else
			ttable->cleanup();
#endif
#ifdef __AMIGA__
	if(seglist)
		UnLoadSeg(seglist);
#else
	FreeLibrary(hInst);
#endif /* __AMIGA__ */
}

/*************
 * DESCRIPTION:   load texture
 * INPUT:         texture     texture
 * OUTPUT:        FALSE if failed else TRUE
 *************/
BOOL IPREVIEW_TEXTURE::Load(TEXTURE *texture)
{
	/* Load Imagine texture  */
#ifdef __AMIGA__
	IM_TTABLE* (*texture_init)(LONG arg0);

	seglist = LoadSeg(texture->name);
	if(!seglist)
		return FALSE;

	*(ULONG*)(&texture_init) = 4*seglist+4;
#ifdef __PPC__
	ttable = ITextureInit(texture_init);
#else
	ttable = texture_init(0x60FFFF);
#endif
#else
	INQUIRETEXTURE InquireTexture;
	PREFS prefs;
	char szBuffer[256];

	prefs.id = ID_TXTP;
	if (prefs.GetPrefs())
		ExpandPath((char *)prefs.data, texture->name, szBuffer);
	else
		strcpy(szBuffer, texture->name);

	prefs.data = NULL; // VERY important !

	hInst = LoadLibrary(szBuffer);
	if (!hInst)
		return FALSE;

	InquireTexture = (INQUIRETEXTURE)GetProcAddress(hInst, "InquireTexture");
	if (!InquireTexture)
		return FALSE;

	ttable = InquireTexture(0x70, 0x1);
#endif

	if(!ttable)
		return FALSE;

	// copy parameters
	memcpy(params, ((IMAGINE_TEXTURE*)texture)->params, 16*sizeof(float));

	form.pos = pos;
	form.orient_x = orient_x;
	form.orient_y = orient_y;
	form.orient_z = orient_z;
	form.size = size;

	return TRUE;
}

/*************
 * DESCRIPTION:   texture work funcion
 * INPUT:         this     texture
 *                pos      position to sample
 *                norm     normal at this point
 * OUTPUT:        
 *************/
void IPREVIEW_TEXTURE::Work(PREVIEW *preview, VECTOR *pos, VECTOR *norm)
{
	VECTOR relpos;

	patch.ptc_pos = *pos;
	patch.ptc_nor = *norm;
	patch.ptc_col = preview->diffuse;
	patch.ptc_ref = preview->reflect;
	patch.ptc_tra = preview->transpar;
	patch.ptc_spc = preview->surf->specular;

	VecSub(pos, &form.pos, &relpos);

#ifdef __PPC__
	ITextureWork(ttable, params, &patch, &relpos, (float*)&form);
#else
	ttable->work(params, &patch, &relpos, (float*)&form);
#endif

	preview->diffuse = patch.ptc_col;
	preview->reflect = patch.ptc_ref;
	preview->transpar = patch.ptc_tra;
	*norm = patch.ptc_nor;
}

/*************
 * DESCRIPTION:   constructor
 * INPUT:         -
 * OUTPUT:        -
 *************/
RPREVIEW_TEXTURE::RPREVIEW_TEXTURE()
{
#ifdef __AMIGA__
	Base = NULL;
#endif
}

/*************
 * DESCRIPTION:   destructor
 * INPUT:         -
 * OUTPUT:        -
 *************/
RPREVIEW_TEXTURE::~RPREVIEW_TEXTURE()
{
#ifdef __AMIGA__
	if(Base)
	{
#if defined(__MIXEDBINARY__) && !defined(__PPC_)
		PPCRTextureCleanup(tinfo->cleanup, tinfo, Base);
#else
		tinfo->cleanup(tinfo);
		CloseLibrary(Base);
#endif
	}
#endif /* __AMIGA__ */
}

/*************
 * DESCRIPTION:   load texture
 * INPUT:         texture     texture
 * OUTPUT:        FALSE if failed else TRUE
 *************/
BOOL RPREVIEW_TEXTURE::Load(TEXTURE *texture)
{
#if !defined(__MIXEDBINARY__) || defined(__PPC__)
#ifdef __AMIGA__
	Base = OpenLibrary(texture->GetName(), 0);
	if(!Base)
		return FALSE;
	TextureBase = Base;
#endif // __AMIGA__
	tinfo = texture_init();
#else
	tinfo = PPC_STUB(texture_init)(texture->GetName(), &Base);
#endif // __MIXEDBINARY__

	this->texture = (RAYSTORM_TEXTURE*)texture;
	return TRUE;
}

/*************
 * DESCRIPTION:   texture work funcion
 * INPUT:         this     texture
 *                pos      position to sample
 *                norm     normal at this point
 * OUTPUT:        -
 *************/
void RPREVIEW_TEXTURE::Work(PREVIEW *preview, VECTOR *pos, VECTOR *norm)
{
	TEXTURE_PATCH ptch;
	VECTOR relpos;

	relpos = *pos;
	m.MultVectMat(&relpos);

	ptch.ambient = preview->ambient;
	ptch.specular = preview->specular;
	ptch.diffuse = preview->diffuse;
	ptch.reflect = preview->reflect;
	ptch.transpar = preview->transpar;
	ptch.difftrans = preview->difftrans;
	ptch.spectrans = preview->spectrans;
	ptch.refphong = preview->refphong;
	ptch.transphong = preview->transphong;
	ptch.foglength = preview->foglength;
	ptch.refrindex = preview->refrindex;
	ptch.translucency = preview->translucency;
	ptch.norm = *norm;

#if defined(__MIXEDBINARY__) && !defined(__PPC__)
	PPCRTextureWork(tinfo, texture->data, &ptch, &relpos);
#else
	tinfo->work(tinfo, texture->data, &ptch, &relpos);
#endif

	preview->ambient = ptch.ambient;
	preview->specular = ptch.specular;
	preview->diffuse = ptch.diffuse;
	preview->reflect = ptch.reflect;
	preview->transpar = ptch.transpar;
	preview->difftrans = ptch.difftrans;
	preview->spectrans = ptch.spectrans;
	preview->refphong = ptch.refphong;
	preview->transphong = ptch.transphong;
	preview->foglength = ptch.foglength;
	preview->refrindex = ptch.refrindex;
	preview->translucency = ptch.translucency;
	*norm = ptch.norm;
}

